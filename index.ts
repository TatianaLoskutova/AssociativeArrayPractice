
// Массив объектов
export const userArray = [
    {id: 101, name: 'Tanya'},
    {id: 323212, name: 'Lena'},
    {id: 1212, name: 'Nastya'},
    {id: 1, name: 'Julia'}
]

// Доставание!!! GET
userArray.find(u => u.id === 1)  // найди мне юзера(u) , id которого u.id. Бегаем, ищем по массиву пока не найдем наше
// O(n) типа от того сколько у нас элементов
userArray[3]// если бы уже знали точный индекс. То тоже моментальная точечная адресация


// Добавление!!! POST
userArray.push(user)  // так делаем если у нас МУТАБЕЛЬНО, т.е можем менять массив. Плюс не факт, что не будет дубликата
// вдруг такой user уже есть
const userCopy = [...userArray, user] // ИММутабельно. Копируем старый array и добавляем новый. Но может быть дубликат
const userCopy = [...userArray.filter(), user] // чтобы не было дублирования

// Удаление!!! DELETE
const userArray = userArray.filter(u => u.id !== user.id) // типа сохрани в массив тех кого не удалять. А ост.
//удалятся автоматическм

// Обновление!!! PUT

// Объект, тут еще ассоциативные массив
export type UsersType = {
    [key: string]: {id: number, name: string} // тип, ты объект у котрого есть ключ, который строка. И значение
}

const users: UsersType = {
    '101': {id: 101, name: 'Tanya'},
    '323212': {id: 323212, name: 'Lena'},
    '1212': {id: 1212, name: 'Nastya'},
    '1': {id: 1, name: 'Julia'}
}

// Доставание!!! GET
users[1] // достали наш объект по ключу 1. Все быстро вкусно. O(1) это Сложность алгоритма!! Разовый прямой запрос

// Добавление!!! POST
const user = {id: 100500, name: 'Igor'}
users[user.id] = user // слышь, user, нам нужен твой id,
// чтобы сделать его строкой(ключом id)те что с '1212' например. Это динамически мы создаем. и потом скармливаем весь
// объект user пож этим id

// Удаление!!! DELETE
delete users[user.id]

// Обновление!!! PUT
users[user.id].name = 'Vitya' // конкретно говорим, что твое имя будет Витя